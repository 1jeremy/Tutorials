<p>
    Taking inspiration from the Fama French five-factor model, we can develop a multi-factor stock selection strategy that focuses on five factors: size, value, quality, profitability, and investment pattern. 
</p>
<p>
    In the following backtest,  we use the terms TotalEquity, BookValuePerShare, OperationProfitMargin, ROE, and TotalAssetsGrowth to account for the five factors, respectively. We then calculate a custom ranking metric for each stock using these five terms. Our algorithm will long the five stocks with the highest scores and short the five stocks with the lowest scores.
</p>
<div class="section-example-container">
<pre class="python">
def FineSelectionFunction(self, fine):
    '''Select securities with highest score on Fama French 5 factors'''
    
    # select stocks with these 5 factors
    
    # Operation profit margin: Quality
    # Book value per share: Value
    # ROE: Profitability
    # TotalEquity: Size
    # TotalAssetsGrowth: Investment Pattern
    filtered = [x for x in fine if x.OperationRatios.OperationMargin.Value
                                and x.ValuationRatios.BookValuePerShare
                                and x.OperationRatios.ROE
                                and x.FinancialStatements.BalanceSheet.TotalEquity
                                and x.OperationRatios.TotalAssetsGrowth]
                                
    
    # sort by factors
    sortedByFactor1 = sorted(filtered, key=lambda x: x.OperationRatios.OperationMargin.Value, reverse=True)
    sortedByFactor2 = sorted(filtered, key=lambda x: x.ValuationRatios.BookValuePerShare, reverse=True)
    sortedByFactor3 = sorted(filtered, key=lambda x: x.OperationRatios.ROE.Value, reverse=True)
    sortedByFactor4 = sorted(filtered, key=lambda x: x.FinancialStatements.BalanceSheet.TotalEquity.Value, reverse=True)
    sortedByFactor5 = sorted(filtered, key=lambda x: x.OperationRatios.TotalAssetsGrowth.Value, reverse=False)
    
    stockBySymbol = {}
    
    # get the rank based on 5 factors for every stock
    for index, stock in enumerate(sortedByFactor1):
        rank1 = index
        rank2 = sortedByFactor2.index(stock)
        rank3 = sortedByFactor3.index(stock)
        rank4 = sortedByFactor4.index(stock)
        rank5 = sortedByFactor5.index(stock)
        avgRank = np.mean([rank1,rank2,rank3,rank4,rank5])
        stockBySymbol[stock.Symbol] = avgRank
        
    sorted_dict = sorted(stockBySymbol.items(), key = lambda x: x[1], reverse = True)
    symbols = [x[0] for x in sorted_dict]
    
    # pick the stocks with the highest scores to long
    self.longSymbols= symbols[:self.num_long]
    # pick the stocks with the lowest scores to short
    self.shortSymbols = symbols[-self.num_short:]
    
    return self.longSymbols + self.shortSymbols   
</pre>
</div>

<p>
    In this example, the portfolio is rebalanced every 30 days and the backtest period runs from Jan 2010 to Aug 2019. You can improve upon this strategy by changing the fundamental factors, the weight of each factor and the rebalance frequency.
</p>

<div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
    <div class="qc-embed-dummy" style="padding-top: 56.25%;"></div>
    <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
        <iframe class="qc-embed-backtest" height="100%" width="100%" style="border: 1px solid #ccc; padding: 0; margin: 0;" src="https://www.quantconnect.com/terminal/processCache?request=embedded_backtest_fd8b4225046a2e9b46d5234a430b9bcd.html"></iframe>
    </div>
</div>
