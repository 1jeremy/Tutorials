<p>
  As the strategy needs the continuous futures contract, we import the custom data from Quandl.
  We create a universe of highly liquid commodity futures that are traded on CME, ICE and CBOT (more contracts can be added using the Quandl API).
  We will use Quandl's daily, non-adjusted price data, which is based on spot-month continuous contract calculations.
</p>
<p>
  The first step is importing the data.
</p>
<div class="section-example-container">
<pre class="python">from QuantConnect.Python import PythonQuandl
for symbol in self.symbols_Settle:
    self.AddData(QuandlFutures, symbol, Resolution.Daily)

class QuandlFutures(PythonQuandl):
    def __init__(self):
        self.ValueColumnName = "Settle"
</pre>
</div>
<p>
  Here we use a 12-month <code>RateOfChange(period)</code> indicator to simulate the momentum return. Here the period is 12 months.
  As we are using the custom data, the indicator initialization should use a historical data request and update the value manually.
  All indicators are saved in the dictionary <code>self.roc</code>.
</p>
<div class="section-example-container">
<pre class="python">self.roc = {}
for symbol in self.symbols:
    self.AddData(QuandlFutures, symbol, Resolution.Daily)
    self.roc[symbol] = RateOfChange(period)
    hist = self.History([symbol], 300, Resolution.Daily).loc[symbol]
    for i in hist.itertuples():
        self.roc[symbol].Update(i.Index, i.value)
</pre>
</div>
<p>
  In <code>OnData(self, data)</code>, indicators for all futures contracts are updated every day with the settlement price.
</p>
<p>
  We take a long position in instruments with positive 12-month momentum and short positions with negative momentum.
</p>
<div class="section-example-container">
    <pre class="python">
        self.long = [symbol for symbol in self.roc if self.roc[symbol].Current.Value > 0]
        self.short =  [symbol for symbol in self.roc if self.roc[symbol].Current.Value < 0]
    </pre>
</div>

<p>
  As we stated in the introduction, a security's volatility can be estimated using a GARCH model or historical volatility. For the sake of simplicity, we use historical volatility. The <code>volatility</code> here is a dictionary containing the reciprocal of 252-day historical volatility.
</p>

<div class="section-example-container">
    <pre class="python">
        hist = self.History(self.Symbol(symbol), 252, Resolution.Daily).loc[symbol]['value']
        log_return = np.log(hist/hist.shift()).dropna().tolist()
        volatility[symbol] = 1/np.std(log_return,ddof = 1)
    </pre>
</div>


<p>
    Then we determine the weights for every contract and place our orders.

</p>
<div class="section-example-container">
    <pre class="python">
for long in self.long:
    weights_long[long] = volatility[long]/sum(volatility.values())
for short in self.short:
    weights_short[short] = volatility[short]/sum(volatility.values())
        
for long in self.long:
    self.SetHoldings(long, 0.5*weights_long[long]/sum(weights_long.values()))
for short in self.short:
    self.SetHoldings(short, -0.5*weights_short[short]/sum(weights_short.values()))
    </pre>
</div>





